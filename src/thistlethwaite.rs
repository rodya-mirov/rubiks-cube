//! Set of functionality corresponding to a Thistlethwaite algorithm solution
//!
//! See for instance: https://www.jaapsch.net/puzzles/thistle.htm
//!
//! Basically this goes as follows:
//!     G0 is the set of all configurations of the cube reachable from <L, R, F, B, U, D>;
//!         that is, all solveable configurations of the cube
//!     G1 is the set of all configurations of the cube reachable from <L, R, F, B, U2, D2>;
//!         that is, where U and D cannot be used singly
//!     G2 is the set of all configurations of the cube reachable from <L, R, F2, B2, U2, D2>;
//!         that is, where only L and R can be used singly
//!     G3 is the set of all configurations of the cube reachable from <L2, R2, F2, B2, U2, D2>;
//!         that is, where only double moves are allowed
//!     G4 is just a solved cube (set of 1 configuration)
//!
//! What you do is, given a configuration, move it into G1 as quickly as possible; then into G2;
//! and so on, until it is solved. Because the coset spaces are relatively small, these problems
//! are individually manageable, and glue together into a not-terrible solution for the cube.
//!
//! Each group can (to some extent) be described "usefully" and then the solution from Gi to Gi+1
//! can be described in those terms.
//!
//! G1 -- an edge piece is "good" if, when it is moved into position using only LRBF moves,
//!         it gets there in the correct orientation. Otherwise it is bad.
//!
//!         Then: G1 is the set of all cube configurations where all the edges are "good."
//!
//!         This also suggests a strategy for moving from G0 to G1 -- a U or D rotation flips the
//!         "goodness" of all affected edges cubies, so we can compute the "goodness" state of a
//!         cube configuration, solve that, then apply the resulting set of moves to the original
//!         cube in order to get it into G1.
//!
//! G2 -- a corner piece is "good" if its "side" facelet is on a side. E.g. if your L and R faces
//!         are red and orange, then every corner cubelet has exactly one facelet which is either
//!         red or orange. Then that facelet can be _on_ a side, that is, on the L or R face, and if
//!         so, it is "good."
//!
//!         Then: G2 is the set of all cube configurations where all the corners are "good"
//!         and where every center edge piece (that is, FU, FD, BU, BD) is in the middle slice.
//!
//!         For this, note that L, R, F2, B2, U2, and D2 moves do not affect any of of the
//!         invariants. For the corner orientation, we should think of the orientation as a number
//!         mod 3 (where 0 is "good," 1 is "cw rotated," and 2 is "ccw rotated"); then F
//!         subtracts one from FUR and FDL (then moves them), while it adds one to FUL and FDR
//!         (then moves them) where all addition / subtraction is mod three. Likewise B
//!         subtracts one from BUR and BDL (then moves them), while it adds one to BUL and BDR
//!         (then moves them).
//!
//!         Thus the computed state is then twofold; a 2x2x2 cube of orientations (numbers mod 3)
//!         and twelve edge pieces which are bools (is middle slice / is not middle slice) which is
//!         solved when all the orientations are zero and the bools are in the right spot.
//!
//! G3 -- this is the trickiest to state clearly what it even is; the source material is unclear
//!         and lots of "plain English summaries" are inconsistent with each other. Doing my best.
//!
//!         What we want to ensure is that, (1) for the edge pieces, the L and R faces are in their
//!         correct slices, (2) the corners are in their correct tetrads, (3) the parity of the edge
//!         permutation is even (which ensures it for the corners as well), and (4) the total twist
//!         of each tetrad is fixed.
//!
//!         Going line by line, this means:
//!         1. We already know the edge pieces are correctly oriented (since we have gotten into G1)
//!             so on the side (say, red and orange) everything is already red or orange. This
//!             calls for getting them completely correct, at least for the edge pieces.
//!         2. A tetrad is a collection of four corner positions which are non-adjacent. Given a
//!             corner cubelet it's well-defined whether it's in the correct tetrad (the goal
//!             position is the correct tetrad; everything adjacent to that is not; everything
//!             adjacent to those _is_, and so on until you're done).
//!         3. and 4. The last bit is just making sure the permutation at the end is solvable in G3,
//!             which is not very easy to describe. It turns out a lot of people have trouble with
//!             this and so we'll come back to it ... someday.
//!
//!         Nevertheless, recalling that G3 is generated by <L, R, F2, B2, U2, D2>, we can describe
//!         the state in those terms. We can describe the state fourfold, according to the four
//!         invariants.
//!
//!         TODO: ugh I still don't understand G3 well enough to explain it

pub use g0g1::solve_to_g1;

mod g0g1 {
    use crate::cube::{Cube, Facelet};
    use crate::moves::{Amt, CanMove, Dir, FullMove};

    /// Invariants from a cube in G0 to describe what's left to get to G1
    #[derive(Copy, Clone, Eq, PartialEq, Debug)]
    struct G0State {
        // each field is "this edge is good"
        // top layer
        uf: bool,
        ub: bool,
        ul: bool,
        ur: bool,
        // mid layer
        fl: bool,
        fr: bool,
        bl: bool,
        br: bool,
        // bot layer
        df: bool,
        db: bool,
        dl: bool,
        dr: bool,
    }

    impl G0State {
        fn is_solved(&self) -> bool {
            self.uf
                && self.ub
                && self.ul
                && self.ur
                && self.fl
                && self.fr
                && self.bl
                && self.br
                && self.df
                && self.db
                && self.dl
                && self.dr
        }
    }

    impl CanMove for G0State {
        fn r(self) -> Self {
            Self {
                ur: self.fr,
                fr: self.dr,
                dr: self.br,
                br: self.ur,
                ..self
            }
        }

        fn l(self) -> Self {
            Self {
                ul: self.bl,
                bl: self.dl,
                dl: self.fl,
                fl: self.ul,
                ..self
            }
        }

        fn u(self) -> Self {
            // negates the top layer as it rotates them; otherwise still
            Self {
                uf: !self.ur,
                ur: !self.ub,
                ub: !self.ul,
                ul: !self.uf,
                ..self
            }
        }

        fn d(self) -> Self {
            // negates the bottom layer as it rotates them; otherwise still
            Self {
                df: !self.dl,
                dl: !self.db,
                db: !self.dr,
                dr: !self.df,
                ..self
            }
        }

        fn b(self) -> Self {
            Self {
                ub: self.br,
                br: self.db,
                db: self.bl,
                bl: self.ub,
                ..self
            }
        }

        fn f(self) -> Self {
            Self {
                uf: self.fl,
                fl: self.df,
                df: self.fr,
                fr: self.uf,
                ..self
            }
        }
    }

    fn to_g1_invariant(cube: &Cube) -> G0State {
        // The suggested algorithm in Thistlethwaite is annoying to deal with in person and in code
        // A simpler way to check orientation is presented in: http://cube.rider.biz/zz.php?p=eoline
        // One quirk is we're trying to be faithful to Thistlethwaite's original group notation,
        // which defines orientation in terms of avoiding U and D, while in many more modern sources
        // (such as the above) define orientation in terms of avoiding F and B. So the spirit still
        // works but all of the details need to be changed.

        let l_color = cube.l.cc.clone();
        let r_color = cube.r.cc.clone();
        let u_color = cube.u.cc.clone();
        let d_color = cube.d.cc.clone();
        let f_color = cube.f.cc.clone();
        let b_color = cube.b.cc.clone();

        let is_lr_color = |f: &Facelet| f == &l_color || f == &r_color;
        let is_ud_color = |f: &Facelet| f == &u_color || f == &d_color;
        let is_fb_color = |f: &Facelet| f == &f_color || f == &b_color;

        // Look at the edges on the L/R faces. If you see:
        //      F/B color it's bad
        //      U/D color you need to look at the side of the edge. If the side is L/R it's bad.
        let lr_good = |lr: &Facelet, other: &Facelet| {
            (!is_fb_color(lr)) && !(is_ud_color(lr) && is_lr_color(other))
        };

        // Then look at the U/D edges on the mid slice. If you see:
        //      F/B color it's bad
        //      U/D color you need to look at the side of the edge. If the side is L/R it's bad.
        let ud_mid_good = |ud: &Facelet, fb: &Facelet| {
            (!is_fb_color(ud)) && !(is_ud_color(ud) && is_lr_color(fb))
        };

        G0State {
            // ud mid edges ...
            uf: ud_mid_good(&cube.u.fc, &cube.f.uc),
            ub: ud_mid_good(&cube.u.bc, &cube.b.uc),
            df: ud_mid_good(&cube.d.fc, &cube.f.dc),
            db: ud_mid_good(&cube.d.bc, &cube.b.dc),
            // l edges
            ul: lr_good(&cube.l.uc, &cube.u.lc),
            fl: lr_good(&cube.l.fc, &cube.f.lc),
            bl: lr_good(&cube.l.bc, &cube.b.lc),
            dl: lr_good(&cube.l.dc, &cube.d.lc),
            // r edges
            ur: lr_good(&cube.r.uc, &cube.u.rc),
            fr: lr_good(&cube.r.fc, &cube.f.rc),
            br: lr_good(&cube.r.bc, &cube.b.rc),
            dr: lr_good(&cube.r.dc, &cube.d.rc),
        }
    }

    const ALL_DIRS: [Dir; 6] = [Dir::U, Dir::D, Dir::B, Dir::F, Dir::L, Dir::R];
    const ALL_AMTS: [Amt; 3] = [Amt::One, Amt::Two, Amt::Rev];

    pub fn solve_to_g1(cube: &Cube) -> Vec<FullMove> {
        let state = to_g1_invariant(cube);

        println!("Got g0 state {state:?}");

        // iterative-deepening DFS; returns true if it found a solution, or false if not
        fn ida(cube: &G0State, running: &mut Vec<FullMove>, max_depth: usize) -> bool {
            if cube.is_solved() {
                return true;
            } else if running.len() >= max_depth {
                return false;
            }

            for dir in ALL_DIRS.iter().copied() {
                if running.last().map(|fm| fm.dir) == Some(dir) {
                    continue;
                }

                for amt in ALL_AMTS.iter().copied() {
                    let fm = FullMove { amt, dir };
                    let next = cube.clone().apply(fm);

                    // for WC there are so many blanks there is a good chance an individual move
                    // will be a no-op, so this cuts runtime by two thirds (!)
                    if &next == cube {
                        continue;
                    }

                    running.push(fm);

                    let found_solution = ida(&next, running, max_depth);

                    if found_solution {
                        return true;
                    }

                    running.pop();
                }
            }

            false
        }

        // Apparently you can solve G0 -> G1 in 7 moves, idk
        const MAX_MOVES: usize = 7;

        for max_depth in 0..=MAX_MOVES {
            let mut attempt = Vec::with_capacity(max_depth);

            let found = ida(&state, &mut attempt, max_depth);

            if found {
                return attempt;
            }
        }

        panic!("idk dude couldn't solve it in {MAX_MOVES} moves, maybe i'm broken")
    }
}
