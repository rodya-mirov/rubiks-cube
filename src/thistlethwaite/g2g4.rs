//! This module handles moving from G2 to G3, as well as G3 to G4.
//!
//! A design principle is that basically G3 is beyond annoying to describe precisely in terms of an
//! invariant that doesn't suck to compute. So here's what we're gonna do instead.
//!
//! G3 is the set of all configurations generated by half-turns: <L2, R2, U2, D2, F2, B2>. You can
//! compute a bunch of invariants, blah blah blah. But here's the real deal -- I can store a cube
//! in 54 bytes. The group G3 has exactly 663,552 elements, which comes out to about 34 megabytes
//! of storage. So fuck it -- I'll precompute the entire set, and we'll define membership in G3
//! by "membership in the set of elements in G3" and just be done.
//!
//! Perf: if that turns out to be slow we can just store permutations of the cubelets instead of
//! all the facelets, since we can't really mess up the orientations once we're in G2.

use std::collections::{HashSet, VecDeque};

use ahash::RandomState;

use crate::cube::Cube;
use crate::moves::{Amt, ApplyMove, Dir, FullMove};
use crate::thistlethwaite::dfs_util;
use crate::thistlethwaite::g2g4::state::{CubeCornerPositions, CubeEdgePositions, CubePositions};

mod state;

const ALL_DIRS: [Dir; 6] = [Dir::U, Dir::D, Dir::B, Dir::F, Dir::L, Dir::R];

const G2_FREE_DIRS: [Dir; 2] = [Dir::L, Dir::R];
const G2_DOUBLE_DIRS: [Dir; 4] = [Dir::U, Dir::D, Dir::F, Dir::B];

pub struct PosCache {
    edges: HashSet<CubeEdgePositions, RandomState>,
    corners: HashSet<CubeCornerPositions, RandomState>,
    full: HashSet<CubePositions, RandomState>,
}

/// Takes about 650ms on my machine with stdlib hashmap
///     Down to 180ms with ahash
pub fn enumerate_g3_pos() -> PosCache {
    let start: CubePositions = CubePositions::make_solved();

    let mut full_states: HashSet<CubePositions, RandomState> = HashSet::default();
    full_states.insert(start.clone());

    let mut to_process = VecDeque::new();
    to_process.push_back(start);

    while let Some(next) = to_process.pop_front() {
        for dir in ALL_DIRS {
            let fm = FullMove { dir, amt: Amt::Two };

            let applied = next.clone().apply(fm);
            if full_states.insert(applied.clone()) {
                to_process.push_back(applied);
            }
        }
    }

    let mut edge_states = HashSet::default();
    let mut corner_states = HashSet::default();

    for state in full_states.iter().cloned() {
        edge_states.insert(state.edges);
        corner_states.insert(state.corners);
    }

    PosCache {
        edges: edge_states,
        corners: corner_states,
        full: full_states,
    }
}

pub fn solve_to_g4(cube: &Cube) -> Vec<FullMove> {
    // Apparently you can solve G1 -> G2 in 10 moves, idk
    const MAX_MOVES: usize = 15;

    dfs_util::solve(
        cube,
        &[],
        &ALL_DIRS,
        CubePositions::from_cube,
        |s| s.is_solved(),
        |_| 0,
        MAX_MOVES,
    )
}

/// Given a cube in G2, solve to G3
pub fn solve_to_g3(cube: &Cube, cache: &PosCache) -> Vec<FullMove> {
    // Apparently you can solve G1 -> G2 in 10 moves, idk
    const MAX_MOVES: usize = 13;

    dfs_util::solve(
        cube,
        &G2_FREE_DIRS,
        &G2_DOUBLE_DIRS,
        CubePositions::from_cube,
        |s| cache.full.contains(s),
        |_| 0,
        MAX_MOVES,
    )
}
