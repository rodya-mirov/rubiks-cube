//! This module handles moving from G2 to G3, as well as G3 to G4.
//!
//! A design principle is that basically G3 is beyond annoying to describe precisely in terms of an
//! invariant that doesn't suck to compute. So here's what we're gonna do instead.
//!
//! G3 is the set of all configurations generated by half-turns: <L2, R2, U2, D2, F2, B2>. You can
//! compute a bunch of invariants, blah blah blah. But here's the real deal -- I can store a cube
//! in 54 bytes. The group G3 has exactly 663,552 elements, which comes out to about 34 megabytes
//! of storage. So fuck it -- I'll precompute the entire set, and we'll define membership in G3
//! by "membership in the set of elements in G3" and just be done.
//!
//! Perf: if that turns out to be slow we can just store permutations of the cubelets instead of
//! all the facelets, since we can't really mess up the orientations once we're in G2.

use std::collections::VecDeque;

// note we import the faster maps/sets everywhere
use ahash::HashSet;

use crate::cube::Cube;
use crate::heuristic_caches::HeuristicCache;
use crate::moves::{Amt, ApplyMove, Dir, FullMove};
use crate::thistlethwaite::dfs_util;
use crate::thistlethwaite::g2g4::state::{CubeCornerPositions, CubeEdgePositions, CubePositions};

mod state;

const ALL_DIRS: [Dir; 6] = [Dir::U, Dir::D, Dir::B, Dir::F, Dir::L, Dir::R];

const G2_FREE_DIRS: [Dir; 2] = [Dir::L, Dir::R];
const G2_DOUBLE_DIRS: [Dir; 4] = [Dir::U, Dir::D, Dir::F, Dir::B];

pub struct PosCache {
    edges: HashSet<CubeEdgePositions>,
    edge_heuristic: HeuristicCache<CubeEdgePositions>,
    corners: HashSet<CubeCornerPositions>,
    corner_heuristic: HeuristicCache<CubeCornerPositions>,
}

/// Takes about 650ms on my machine with stdlib hashmap
///     Down to 180ms with ahash
pub fn enumerate_g3_pos() -> PosCache {
    let start: CubePositions = CubePositions::make_solved();

    let mut full_states: HashSet<CubePositions> = HashSet::default();
    full_states.insert(start.clone());

    let mut to_process = VecDeque::new();
    to_process.push_back(start);

    while let Some(next) = to_process.pop_front() {
        for dir in ALL_DIRS {
            let fm = FullMove { dir, amt: Amt::Two };

            let applied = next.clone().apply(fm);
            if full_states.insert(applied.clone()) {
                to_process.push_back(applied);
            }
        }
    }

    let mut edge_states = HashSet::default();
    let mut corner_states = HashSet::default();

    for state in full_states.iter().cloned() {
        edge_states.insert(state.edges);
        corner_states.insert(state.corners);
    }

    // This just sort of makes me happy to double-check
    assert_eq!(edge_states.len() * corner_states.len(), full_states.len());

    // Setting up corner heuristic takes about 7ms; for purity reasons we should precompute
    // and save it somewhere, but like ... who cares
    let corner_heuristic = HeuristicCache::from_set(&corner_states, &G2_FREE_DIRS, &G2_DOUBLE_DIRS);

    // TODO perf: constructing the edges might actually take so long (around 600ms) this is not a good use of time
    let edge_heuristic = HeuristicCache::from_set(&edge_states, &G2_FREE_DIRS, &G2_DOUBLE_DIRS);

    PosCache {
        edges: edge_states,
        edge_heuristic,
        corners: corner_states,
        corner_heuristic,
    }
}

pub struct G3toG4Cache {
    corner_heuristic: HeuristicCache<CubeCornerPositions>,
    edge_heuristic: HeuristicCache<CubeEdgePositions>,
}

impl G3toG4Cache {
    pub fn initialize() -> Self {
        Self {
            corner_heuristic: HeuristicCache::from_goal(
                CubeCornerPositions::make_solved(),
                &[],
                &ALL_DIRS,
            ),
            edge_heuristic: HeuristicCache::from_goal(
                CubeEdgePositions::make_solved(),
                &[],
                &ALL_DIRS,
            ),
        }
    }
}

pub fn solve_to_g4(cube: &Cube, cache: &G3toG4Cache) -> Vec<FullMove> {
    const MAX_MOVES: usize = 15;

    dfs_util::solve(
        CubePositions::from_cube(cube),
        &[],
        &ALL_DIRS,
        |s| s.is_solved(),
        |s| {
            cache
                .corner_heuristic
                .evaluate(&s.corners)
                .max(cache.edge_heuristic.evaluate(&s.edges))
        },
        MAX_MOVES,
    )
}

/// Given a cube in G2, solve to G3
pub fn solve_to_g3(cube: &Cube, cache: &PosCache) -> Vec<FullMove> {
    const MAX_MOVES: usize = 13;

    dfs_util::solve(
        CubePositions::from_cube(cube),
        &G2_FREE_DIRS,
        &G2_DOUBLE_DIRS,
        |s| cache.edges.contains(&s.edges) && cache.corners.contains(&s.corners),
        |c| {
            cache
                .corner_heuristic
                .evaluate(&c.corners)
                .max(cache.edge_heuristic.evaluate(&c.edges))
        },
        MAX_MOVES,
    )
}
