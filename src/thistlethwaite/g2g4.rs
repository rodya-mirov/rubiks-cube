//! This module handles moving from G2 to G3, as well as G3 to G4.
//!
//! A design principle is that basically G3 is beyond annoying to describe precisely in terms of an
//! invariant that doesn't suck to compute. So here's what we're gonna do instead.
//!
//! G3 is the set of all configurations generated by half-turns: <L2, R2, U2, D2, F2, B2>. You can
//! compute a bunch of invariants, blah blah blah. But here's the real deal -- I can store a cube
//! in 54 bytes. The group G3 has exactly 663,552 elements, which comes out to about 34 megabytes
//! of storage. So fuck it -- I'll precompute the entire set, and we'll define membership in G3
//! by "membership in the set of elements in G3" and just be done.
//!
//! Perf: if that turns out to be slow we can just store permutations of the cubelets instead of
//! all the facelets, since we can't really mess up the orientations once we're in G2.

use std::collections::VecDeque;

// note we import the faster maps/sets everywhere
use ahash::{HashMap, HashSet};

use crate::cube::Cube;
use crate::moves::{Amt, ApplyMove, Dir, FullMove};
use crate::thistlethwaite::dfs_util;
use crate::thistlethwaite::g2g4::state::{CubeCornerPositions, CubeEdgePositions, CubePositions};

mod state;

const ALL_DIRS: [Dir; 6] = [Dir::U, Dir::D, Dir::B, Dir::F, Dir::L, Dir::R];

const G2_FREE_DIRS: [Dir; 2] = [Dir::L, Dir::R];
const G2_DOUBLE_DIRS: [Dir; 4] = [Dir::U, Dir::D, Dir::F, Dir::B];
const ALL_AMTS: [Amt; 3] = [Amt::One, Amt::Two, Amt::Rev];

pub struct PosCache {
    edges: HashSet<CubeEdgePositions>,
    corners: HashSet<CubeCornerPositions>,
}

/// Takes about 650ms on my machine with stdlib hashmap
///     Down to 180ms with ahash
pub fn enumerate_g3_pos() -> PosCache {
    let start: CubePositions = CubePositions::make_solved();

    let mut full_states: HashSet<CubePositions> = HashSet::default();
    full_states.insert(start.clone());

    let mut to_process = VecDeque::new();
    to_process.push_back(start);

    while let Some(next) = to_process.pop_front() {
        for dir in ALL_DIRS {
            let fm = FullMove { dir, amt: Amt::Two };

            let applied = next.clone().apply(fm);
            if full_states.insert(applied.clone()) {
                to_process.push_back(applied);
            }
        }
    }

    let mut edge_states = HashSet::default();
    let mut corner_states = HashSet::default();

    for state in full_states.iter().cloned() {
        edge_states.insert(state.edges);
        corner_states.insert(state.corners);
    }

    // This just sort of makes me happy to double-check
    assert_eq!(edge_states.len() * corner_states.len(), full_states.len());

    PosCache {
        edges: edge_states,
        corners: corner_states,
    }
}

pub fn solve_to_g4(cube: &Cube) -> Vec<FullMove> {
    let corner_heuristic = CornerPosHeuristicIntoG4::initialize();

    const MAX_MOVES: usize = 15;

    dfs_util::solve(
        CubePositions::from_cube(cube),
        &[],
        &ALL_DIRS,
        |s| s.is_solved(),
        |s| corner_heuristic.evaluate(&s.corners),
        MAX_MOVES,
    )
}

// currently focusing on corners; there are, like, too many edges
struct CornerPosHeuristicIntoG3 {
    known_costs: HashMap<CubeCornerPositions, usize>,
}

impl CornerPosHeuristicIntoG3 {
    fn from_set(goal_states: &HashSet<CubeCornerPositions>) -> Self {
        let mut known_costs = HashMap::default();

        // we don't want to do DFS here -- instead, we'll actually iterate through and find every
        // single accessible position and the cost to get there

        let mut to_process: VecDeque<(CubeCornerPositions, usize)> = VecDeque::new();

        for c in goal_states {
            to_process.push_back((c.clone(), 0));
        }

        while let Some((pos, cost)) = to_process.pop_front() {
            let existing = known_costs.get(&pos);
            // note that by use of the VecDeque as a queue, we guarantee that we generate everything
            // in the most efficient manner possible, so if we've seen it before, this is not an
            // improvement on the previous
            if existing.is_some() {
                continue;
            }

            known_costs.insert(pos.clone(), cost);

            for dir in G2_FREE_DIRS {
                for amt in ALL_AMTS {
                    let fm = FullMove { dir, amt };
                    let next = pos.clone().apply(fm);
                    let next_cost = cost + 1;
                    to_process.push_back((next, next_cost));
                }
            }
            for dir in G2_DOUBLE_DIRS {
                let amt = Amt::Two;
                let fm = FullMove { dir, amt };
                let next = pos.clone().apply(fm);
                let next_cost = cost + 1;
                to_process.push_back((next, next_cost));
            }
        }

        Self { known_costs }
    }

    fn evaluate(&self, edge_pos: &CubeCornerPositions) -> usize {
        if let Some(&cost) = self.known_costs.get(&edge_pos) {
            return cost;
        }

        panic!("Should have covered everything really nicely");
    }
}

// currently focusing on corners; there are, like, too many edges
struct CornerPosHeuristicIntoG4 {
    known_costs: HashMap<CubeCornerPositions, usize>,
}

impl CornerPosHeuristicIntoG4 {
    fn initialize() -> Self {
        let mut known_costs = HashMap::default();

        // we don't want to do DFS here -- instead, we'll actually iterate through and find every
        // single accessible position and the cost to get there

        let mut to_process: VecDeque<(CubeCornerPositions, usize)> = VecDeque::new();

        to_process.push_back((CubeCornerPositions::make_solved(), 0));

        while let Some((pos, cost)) = to_process.pop_front() {
            let existing = known_costs.get(&pos);
            // note that by use of the VecDeque as a queue, we guarantee that we generate everything
            // in the most efficient manner possible, so if we've seen it before, this is not an
            // improvement on the previous
            if existing.is_some() {
                continue;
            }

            known_costs.insert(pos.clone(), cost);

            for dir in ALL_DIRS {
                let amt = Amt::Two;
                let fm = FullMove { dir, amt };
                let next = pos.clone().apply(fm);
                let next_cost = cost + 1;
                to_process.push_back((next, next_cost));
            }
        }

        Self { known_costs }
    }

    fn evaluate(&self, edge_pos: &CubeCornerPositions) -> usize {
        if let Some(&cost) = self.known_costs.get(&edge_pos) {
            return cost;
        }

        panic!("Should have covered everything really nicely");
    }
}

/// Given a cube in G2, solve to G3
pub fn solve_to_g3(cube: &Cube, cache: &PosCache) -> Vec<FullMove> {
    const MAX_MOVES: usize = 13;

    // TODO: get edges in here too
    // Setting up corner heuristic takes about 7ms; for purity reasons we should precompute
    // and save it somewhere, but like ... who cares
    let corner_heuristic = CornerPosHeuristicIntoG3::from_set(&cache.corners);

    dfs_util::solve(
        CubePositions::from_cube(cube),
        &G2_FREE_DIRS,
        &G2_DOUBLE_DIRS,
        |s| cache.edges.contains(&s.edges) && cache.corners.contains(&s.corners),
        |c| corner_heuristic.evaluate(&c.corners),
        MAX_MOVES,
    )
}
