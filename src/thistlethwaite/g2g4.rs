//! This module handles moving from G2 to G3, as well as G3 to G4.
//!
//! A design principle is that basically G3 is beyond annoying to describe precisely in terms of an
//! invariant that doesn't suck to compute. So here's what we're gonna do instead.
//!
//! G3 is the set of all configurations generated by half-turns: <L2, R2, U2, D2, F2, B2>. You can
//! compute a bunch of invariants, blah blah blah. But here's the real deal -- I can store a cube
//! in 54 bytes. The group G3 has exactly 663,552 elements, which comes out to about 34 megabytes
//! of storage. So fuck it -- I'll precompute the entire set, and we'll define membership in G3
//! by "membership in the set of elements in G3" and just be done.
//!
//! Perf: if that turns out to be slow we can just store permutations of the cubelets instead of
//! all the facelets, since we can't really mess up the orientations once we're in G2.

use std::collections::{HashSet, VecDeque};
use std::time::Instant;

use ahash::RandomState;

use crate::cube::Cube;
use crate::moves::{Amt, ApplyMove, Dir, FullMove};
use crate::thistlethwaite::g2g4::state::{CubeCornerPositions, CubeEdgePositions, CubePositions};

mod state;

const ALL_DIRS: [Dir; 6] = [Dir::U, Dir::D, Dir::B, Dir::F, Dir::L, Dir::R];

const G2_FREE_DIRS: [Dir; 2] = [Dir::L, Dir::R];
const G2_DOUBLE_DIRS: [Dir; 4] = [Dir::U, Dir::D, Dir::F, Dir::B];
const ALL_AMTS: [Amt; 3] = [Amt::One, Amt::Two, Amt::Rev];

fn can_follow(last: Option<Dir>, next: Dir) -> bool {
    if last.is_none() {
        return true;
    }

    let last = last.unwrap();

    // can't repeat a direction, and if two directions commute, have to pick an order
    // so with no significance -- B before F, L before R, D before U
    if last == next {
        false
    } else if last == Dir::F && next == Dir::B {
        false
    } else if last == Dir::R && next == Dir::L {
        false
    } else if last == Dir::U && next == Dir::D {
        false
    } else {
        true
    }
}

pub struct PosCache {
    edges: HashSet<CubeEdgePositions, RandomState>,
    corners: HashSet<CubeCornerPositions, RandomState>,
    full: HashSet<CubePositions, RandomState>,
}

/// Takes about 650ms on my machine with stdlib hashmap
///     Down to 180ms with ahash
pub fn enumerate_g3_pos() -> PosCache {
    let start: CubePositions = CubePositions::make_solved();

    let mut full_states: HashSet<CubePositions, RandomState> = HashSet::default();
    full_states.insert(start.clone());

    let mut to_process = VecDeque::new();
    to_process.push_back(start);

    while let Some(next) = to_process.pop_front() {
        for dir in ALL_DIRS {
            let fm = FullMove { dir, amt: Amt::Two };

            let applied = next.clone().apply(fm);
            if full_states.insert(applied.clone()) {
                to_process.push_back(applied);
            }
        }
    }

    let mut edge_states = HashSet::default();
    let mut corner_states = HashSet::default();

    for state in full_states.iter().cloned() {
        edge_states.insert(state.edges);
        corner_states.insert(state.corners);
    }

    PosCache {
        edges: edge_states,
        corners: corner_states,
        full: full_states,
    }
}

pub fn solve_to_g4(cube: &Cube) -> Vec<FullMove> {
    // just solve positions using ID-DFS
    let start_state = CubePositions::from_cube(cube);

    // iterative-deepening DFS; returns true if it found a solution, or false if not
    fn ida(cube: &CubePositions, running: &mut Vec<FullMove>, max_depth: usize) -> bool {
        if cube.is_solved() {
            return true;
        } else if running.len() >= max_depth {
            return false;
        }

        for dir in ALL_DIRS {
            if !can_follow(running.last().map(|fm| fm.dir), dir) {
                continue;
            }

            let amt = Amt::Two;

            let fm = FullMove { amt, dir };

            // TODO: make this next bit into a macro so I can reuse it?
            let next = cube.clone().apply(fm);

            // for WC there are so many blanks there is a good chance an individual move
            // will be a no-op, so this cuts runtime by two thirds (!)
            if &next == cube {
                continue;
            }

            running.push(fm);

            let found_solution = ida(&next, running, max_depth);

            if found_solution {
                return true;
            }

            running.pop();
        }

        false
    }

    // Magic math says this is the worst-possible solve length to get to solved
    const MAX_MOVES: usize = 15;

    let start = Instant::now();
    for fuel in 0..=MAX_MOVES {
        if start.elapsed().as_millis() > 3000 {
            println!(
                "   Getting to G4 going slow ... trying with fuel {} i guess (elapsed {:?})",
                fuel,
                start.elapsed()
            );
        }
        let mut running = Vec::new();
        let solved = ida(&start_state, &mut running, fuel);

        if solved {
            return running;
        }
    }

    panic!("Couldn't solve it I guess lol")
}

/// Given a cube in G2, solve to G3
pub fn solve_to_g3(cube: &Cube, cache: &PosCache) -> Vec<FullMove> {
    let start_state = CubePositions::from_cube(cube);

    // iterative-deepening DFS; returns true if it found a solution, or false if not
    fn ida(
        cube: &CubePositions,
        running: &mut Vec<FullMove>,
        max_depth: usize,
        cache: &PosCache,
    ) -> bool {
        if cache.full.contains(cube) {
            return true;
        } else if running.len() >= max_depth {
            return false;
        }

        for dir in G2_DOUBLE_DIRS {
            if !can_follow(running.last().map(|fm| fm.dir), dir) {
                continue;
            }

            let amt = Amt::Two;

            let fm = FullMove { amt, dir };

            // TODO: make this next bit into a macro so I can reuse it?
            let next = cube.clone().apply(fm);

            // for WC there are so many blanks there is a good chance an individual move
            // will be a no-op, so this cuts runtime by two thirds (!)
            if &next == cube {
                continue;
            }

            running.push(fm);

            let found_solution = ida(&next, running, max_depth, cache);

            if found_solution {
                return true;
            }

            running.pop();
        }

        for dir in G2_FREE_DIRS.iter().copied() {
            if !can_follow(running.last().map(|fm| fm.dir), dir) {
                continue;
            }

            for amt in ALL_AMTS.iter().copied() {
                let fm = FullMove { amt, dir };
                let next = cube.clone().apply(fm);

                running.push(fm);

                let found_solution = ida(&next, running, max_depth, cache);

                if found_solution {
                    return true;
                }

                running.pop();
            }
        }

        false
    }

    // Magic math says this is the worst-possible solve length to get to G3, and I hope I don't see
    // it, because the branching factor is BAD (still 12 at this stage, and it's big enough)
    const MAX_MOVES: usize = 13;

    let start = Instant::now();
    for fuel in 0..=MAX_MOVES {
        if start.elapsed().as_millis() > 3000 {
            println!(
                "   Getting to G3 going slow ... trying with fuel {} i guess (elapsed {:?})",
                fuel,
                start.elapsed()
            );
        }
        let mut running = Vec::new();
        let solved = ida(&start_state, &mut running, fuel, cache);

        if solved {
            return running;
        }
    }

    panic!("Couldn't solve it I guess lol")
}
